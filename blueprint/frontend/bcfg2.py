"""
bcfg2 configuration generator.
"""

import codecs
import logging
import os
import os.path
import platform
import re
import sys
import tarfile

try:
    import lxml.etree
except ImportError:
    print("The bcfg2 configuration generator requires the lxml python module")

# bcfg2 writes xml, shell comments not understood
DISCLAIMER = """<!--
Automatically generated by blueprint(7).
-->
"""


def bcfg2(blueprint, relaxed=False):
    """
    Generate bcfg2 code.
    """
    repo = Repo(blueprint.name, relaxed=relaxed)
    try:
        plat = platform.linux_distribution()[0].lower()
    except AttributeError:
        plat = platform.dist()[0].lower()

    def path(pathname, fprops):
        """
        Create a Path entry.

        pathname: filename
        fprops:   various file properties
        """
        repo.addpath(pathname, fprops)

    def package(manager, package, version):
        """
        Create a package entry.
        """
        repo.package(manager, package, version)

    def service(manager, service):
        """
        Create a service entry.
        """
        smap = {'centos': 'chkconfig',
                'redhat': 'chkconfig',
                'debian': 'deb',
                'ubuntu': 'deb'}
        if manager == 'sysvinit':
            stype = smap[plat]
        else:
            stype = manager

        repo.service(stype, service)

    blueprint.walk(file=path,
                   package=package,
                   service=service)

    return repo


class Repo(object):
    """
    bcfg2 repository.
    """
    def __init__(self, name, relaxed=False):
        """
        """
        self.comment = DISCLAIMER
        self.name = name
        self.relaxed = relaxed
        self.b = Bundle(name, comment=DISCLAIMER)
        self.r = Rules(name, comment=DISCLAIMER)
        self.plugs = ['Bundler', 'Rules', 'Cfg']
        self.files = []

    def addpath(self, pathname, fprops):
        """
        Add a Path entry to the specification.
        """
        self.b.path(pathname)
        if 'template' in fprops:
            logging.warning('file template {0} won\'t appear in generated '
                            'bcfg2 output'.format(pathname))
            return
        if fprops['mode'] in ['120000', '120777']:
            self.r.symlink(pathname,
                           group=fprops['group'],
                           owner=fprops['owner'],
                           to=fprops['content'])
            return
        if 'source' in fprops:
            logging.warning('Source tarballs are unsupported by bcfg2. '
                            'Please build a package for you distribution.')
        else:
            cfgent = {}

            if fprops['encoding'] == 'plain':
                cfgent['encoding'] = sys.getdefaultencoding()
                del fprops['encoding']

            cfgent['name'] = pathname
            cfgent['paranoid'] = 'False'
            cfgent['source'] = pathname[1:]
            for key, val in fprops.items():
                if key == 'mode':
                    # bcfg2 uses perms attribute
                    cfgent['perms'] = fprops['mode'][-4:]
                else:
                    cfgent[key] = val
            self.files.append(cfgent)

    def package(self, manager, package, version):
        """
        Create a package resource.
        """
        if manager == package:
            return

        if manager in ('apt', 'yum'):
            if self.relaxed or version is None:
                self.b.package(package)
                self.r.package(package, type=manager)
            else:
                self.b.package(package)
                self.r.package(package, pkgtype=manager, version=version)

        # AWS cfn-init templates may specify RPMs to be installed from URLs,
        # which are specified as versions.
        elif 'rpm' == manager:
            self.b.rpm_package(package)
            self.r.rpm_package(package, source=version)

        # All types of gems get to have package resources.
        elif 'rubygems' == manager:
            pass  # need to build rpms
        elif re.search(r'ruby', manager) is not None:
            pass  # need to build rpms

        # these should all be Actions, i think
        else:
            self.b.action(manager(package, version, self.relaxed))
            self.r.action(manager(package, version, self.relaxed))

    def service(self, servicetype, service):
        """
        Create a Service entry.
        """
        self.b.service(service)
        self.r.service(service, servicetype)

    def writexml(self, fname, encoding='utf-8'):
        """
        Helper function for writing out xml files.
        """
        if fname.split('/')[1] == 'Bundler':
            data = lxml.etree.tostring(self.b.bundle, pretty_print=True)
        elif fname.split('/')[1] == 'Rules':
            data = lxml.etree.tostring(self.r.rules, pretty_print=True)

        fhandle = codecs.open(fname, 'w', encoding=encoding)
        fhandle.write(data)
        fhandle.close()

    def dumpf(self, gzip=False):
        """
        Generate Bcfg2 repository. The directory structure is the same
        as what is normally found in /var/lib/bcfg2.
        """
        os.mkdir(self.name)
        for plug in self.plugs:
            os.mkdir(os.path.join(self.name, plug))
            if plug in ['Bundler', 'Rules']:
                fname = os.path.join(self.name, '%s/blueprint.xml' % plug)
                self.writexml(fname)
            elif plug == 'Cfg':
                for cfgent in self.files:
                    pathdir = os.path.join(self.name, '%s/%s' %
                                           (plug, cfgent['source']))
                    os.makedirs(pathdir)
                    fname = os.path.join('%s/%s' %
                                         (pathdir,
                                          cfgent['source'].split('/')[-1]))
                    fhandle = codecs.open(fname, 'w',
                                          encoding=cfgent['encoding'])
                    try:
                        fhandle.write(cfgent['content'])
                    except UnicodeDecodeError:
                        print(cfgent['name'])
                    fhandle.close()
                    iname = os.path.join(pathdir, 'info.xml')
                    infoxml = lxml.etree.Element('FileInfo')
                    infoxml.append(\
                        lxml.etree.Element('Info',
                                           perms=cfgent['perms'],
                                           group=cfgent['group'],
                                           owner=cfgent['owner'],
                                           encoding=cfgent['encoding'],
                                           paranoid=cfgent['paranoid']))
                    data = lxml.etree.tostring(infoxml, pretty_print=True)
                    fhandle = codecs.open(iname, 'w', encoding='utf-8')
                    fhandle.write(data)
                    fhandle.close()
        if gzip:
            filename = 'bcfg2-{0}.tar.gz'.format(self.name)
            tarball = tarfile.open(filename, 'w:gz')
            tarball.add(self.name)
            tarball.close()
            return filename
        return self.name


class Bundle(object):
    """
    A bcfg2 Bundle contains groups of inter-dependent configuration entries,
    such as the combination of packages, configuration files, and service
    activations that comprise typical Unix daemons.

    Note that for the purposes of blueprint, all entries will be compiled
    into a single Bundle. It is up to the user to determine which groups
    of entries belong in a Bundle and rearrange them appropriately.
    """

    def __init__(self, name, comment=None):
        """
        """
        if name is None:
            self.name = 'blueprint-generated-bcfg2-bundle'
        else:
            self.name = str(name)
        self.comment = comment
        self.bundle = lxml.etree.Element('Bundle', name=self.name)

    def package(self, name):
        """
        Create a Package entry.
        """
        belem = lxml.etree.Element('Package', name=name)
        self.bundle.append(belem)

    def action(self, name):
        """
        Create an Action entry.
        """
        belem = lxml.etree.Element('Action', name="".join(name.split()))
        self.bundle.append(belem)

    def path(self, name):
        """
        Create an abstract Path entry.
        """
        belem = lxml.etree.Element('Path', name=name)
        self.bundle.append(belem)

    def service(self, name):
        """
        Create an abstract Service entry.
        """
        belem = lxml.etree.Element('Service', name=name)
        self.bundle.append(belem)


class Rules(object):
    """
    A bcfg2 Rules file contains the literal components of the
    configuration entries referenced in Bundler.
    """

    def __init__(self, name, comment=None):
        """
        """
        if name is None:
            self.name = 'blueprint-generated-bcfg2-bundle'
        else:
            self.name = str(name)
        self.comment = comment
        self.rules = lxml.etree.Element("Rules", priority='1')

    def package(self, name, pkgtype=None, **kwargs):
        """
        Create a Package entry.
        """
        # here we add the literal configuration bits
        relem = lxml.etree.Element('Package',
                                   name=name,
                                   type=pkgtype,
                                   version=kwargs['version'])
        self.rules.append(relem)

    def action(self, name):
        """
        Create an Action entry.
        """
        relem = lxml.etree.Element('Action',
                                   name="".join(name.split()),
                                   command=name,
                                   when='modified',
                                   timing='post')
        self.rules.append(relem)

    def symlink(self, name, **kwargs):
        """
        Create a Path type='symlink' entry.
        """
        etype = 'symlink'
        relem = lxml.etree.Element('Path',
                                   name=name,
                                   type=etype)
        for key, val in kwargs.items():
            relem.set(key, val)
        self.rules.append(relem)

    def service(self, name, servicetype):
        """
        Create an literal Service entry.
        """
        relem = lxml.etree.Element('Service',
                                   name=name,
                                   type=servicetype,
                                   status='on')
        self.rules.append(relem)
